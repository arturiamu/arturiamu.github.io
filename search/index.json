[{"content":"现状及问题 在golang开发中我们经常会使用gin作为web框架，gin一直以高性能和简单著称，并且有十分完善的官方文档。然而gin的错误处理却一直以来都被人吐槽， 正常情况下我们在handler层需要根据service层返回的结果给前端相应的响应内容，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { r := gin.Default() r.GET(\u0026#34;/hello\u0026#34;, helloHandler) r.GET(\u0026#34;/world\u0026#34;, worldHandler) r.Run() } func helloHandler(c *gin.Context) { resp, err := helloService.Hello() if err != nil { c.JSON(http.StatusInternalServerError, gin.H{ \u0026#34;message\u0026#34;: err.Error(), \u0026#34;data\u0026#34;: nil, }) return } c.JSON(http.StatusInternalServerError, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;ok\u0026#34;, \u0026#34;data\u0026#34;: resp, }) } func worldHandler(c *gin.Context) { resp, err := worldService.World() if err != nil { c.JSON(http.StatusInternalServerError, gin.H{ \u0026#34;message\u0026#34;: err.Error(), \u0026#34;data\u0026#34;: nil, }) return } c.JSON(http.StatusInternalServerError, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;ok\u0026#34;, \u0026#34;data\u0026#34;: resp, }) } 在每个handler中重复判断service是否返回异常未免太过繁琐，接下来我们通过golang的函数编程能力，使用中间件进行处理\n简单方案 使用中间件改变handler函数，在中间件中处理返回逻辑\n定义返回结构体、异常处理函数以及中间件Wrapper 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package middleware import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;net/http\u0026#34; ) // 返回结构体 type resp struct { Code int `json:\u0026#34;code\u0026#34;` Message string `json:\u0026#34;message\u0026#34;` Data any `json:\u0026#34;data\u0026#34;` } func errResp(message string) resp { return resp{ Code: http.StatusInternalServerError, Message: message, Data: nil, } } func okResp(data interface{}) resp { return resp{ Code: http.StatusOK, Message: \u0026#34;ok\u0026#34;, Data: data, } } // ExceptionHandlerFunc 异常处理函数 type ExceptionHandlerFunc func(c *gin.Context) (data any, err error) // Wrapper 中间件 func Wrapper(handlerFunc ExceptionHandlerFunc) func(c *gin.Context) { return func(c *gin.Context) { data, err := handlerFunc(c) if err != nil { c.JSON(http.StatusOK,errResp(err.Error())) return } c.JSON(http.StatusOK, okResp(data)) } } 修改router方法注册以及handler函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { r := gin.Default() r.GET(\u0026#34;/hello\u0026#34;, middleware.Wrapper(helloHandler)) // 使用Wrapper中间件 r.GET(\u0026#34;/world\u0026#34;, middleware.Wrapper(worldHandler)) // 使用Wrapper中间件 r.Run() } // 将handler改写为ExceptionHandlerFunc类型 func helloHandler(c *gin.Context)(data any, err error) { // 省略参数获取、验证等流程 resp, err := helloService.Hello() // 从service获取结果并且处理返回 // 省略对resp的处理 return resp, err } // 将handler改写为ExceptionHandlerFunc类型 func worldHandler(c *gin.Context)(data any, err error) { // 省略参数获取、验证等流程 return worldService.World() // 直接返回service结果 } 从代码可以看出，使用该方法可以简化handler方法的逻辑，并且实现起来相对简单\n复杂方案 自定义错误类型、错误处理函数并在中间件中统一处理\n定义结构体，实现Error接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // api错误的结构体 type APIException struct { Code int `json:\u0026#34;-\u0026#34;` ErrorCode int `json:\u0026#34;error_code\u0026#34;` Msg string `json:\u0026#34;msg\u0026#34;` Request string `json:\u0026#34;request\u0026#34;` } // 实现接口 func (e *APIException) Error() string { return e.Msg } func newAPIException(code int, errorCode int,msg string) *APIException { return \u0026amp;APIException{ Code:code, ErrorCode:errorCode, Msg:msg, } } 定义错误处理的函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const ( SERVER_ERROR = 1000 // 系统错误 NOT_FOUND = 1001 // 401错误 UNKNOWN_ERROR = 1002 // 未知错误 PARAMETER_ERROR = 1003 // 参数错误 AUTH_ERROR = 1004 // 错误 ) // 500 错误处理 func ServerError() *APIException { return newAPIException(http.StatusInternalServerError,SERVER_ERROR,http.StatusText(http.StatusInternalServerError)) } // 404 错误 func NotFound() *APIException { return newAPIException(http.StatusNotFound,NOT_FOUND,http.StatusText(http.StatusNotFound)) } // 未知错误 func UnknownError(message string) *APIException { return newAPIException(http.StatusForbidden,UNKNOWN_ERROR,message) } // 参数错误 func ParameterError(message string) *APIException { return newAPIException(http.StatusBadRequest,PARAMETER_ERROR,message) } 定义中间件统一处理错误 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func wrapper(handler HandlerFunc) func(c *gin.Context) { return func(c *gin.Context) { var ( err error ) err = handler(c) if err != nil { var apiException *APIException if h,ok := err.(*APIException); ok { apiException = h }else if e, ok := err.(error); ok { if gin.Mode() == \u0026#34;debug\u0026#34; { // 错误 apiException = UnknownError(e.Error()) }else{ // 未知错误 apiException = UnknownError(e.Error()) } }else{ apiException = ServerError() } apiException.Request = c.Request.Method + \u0026#34; \u0026#34;+ c.Request.URL.String() c.JSON(apiException.Code,apiException) return } } } 定义404错误处理函数 1 2 3 4 5 6 func HandleNotFound(c *gin.Context) { handleErr := NotFound() handleErr.Request = c.Request.Method + \u0026#34; \u0026#34; + c.Request.URL.String() c.JSON(handleErr.Code,handleErr) return } 使用 1 2 3 4 5 6 7 func main() { r := gin.Default() r.NoMethod(HandleNotFound) r.NoRoute(HandleNotFound) r.GET(\u0026#34;/hello\u0026#34;, wrapper(world)) r.Run() } ","date":"2023-09-13T22:37:12+08:00","permalink":"https://arturiamu.github.io/post/gin-global-err/","title":"gin中间件统一返回结果、处理错误"},{"content":"最近偶然刷到了B站UP主 Erik_Tse 的视频，了解到了一些代码抽象艺术，感觉很有意思， 所以特地开篇博客总结记录一下，欢迎大家补充~\n抽象小技巧 使用奇怪的变量名 滥用宏定义 简单操作复杂化 。。。。。。 抽象案例 用位运算代替加法 a + b = a ^ b + ((a \u0026amp; b) \u0026lt;\u0026lt; 1)\n1 2 3 4 5 // 计算 x + y int add(int a,int a){ if (!a) return b; return add((x\u0026amp;y)\u0026lt;\u0026lt;1, x^y); } 使用I和l组合作为变量名 1 2 3 4 5 6 int main(){ int IIIIIlllllIlIlllIIIIIlllllIlIlll; cin \u0026gt;\u0026gt; IIIIIlllllIlIlllIIIIIlllllIlIlll; cout \u0026lt;\u0026lt; IIIIIlllllIlIlll \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 使用奇怪宏定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; #define false 1 #define true 0 #define _ int #define ___ 1 using namespace std; _ main(){ _ llllIlIlllIIIIllIlIl;cin \u0026gt;\u0026gt; llllIlIlllIIIIllIlIl; _ llllIlIlllIlllIlIlllIIIII = 0; for (_ __ = ___;__ \u0026lt;= llllIlIlllIIIIllIlIl / __;__ += false){ if (llllIlIlllIIIIllIlIl % __ == 0){ llllIlIlllIlllIlIlllIIIII += false; if (__ != llllIlIlllIIIIllIlIl){ llllIlIlllIlllIlIlllIIIII += false; } } } cout \u0026lt;\u0026lt; llllIlIlllIlllIlIlllIIIII; return 0; } 让人摸不着头脑 尊嘟假嘟\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #define false 1 #define true 0 using namespace std; struct ZDJD{ bool O(bool x){ return x ? true : false; } }o; int mian(){ int a[] = {1, 2, 3, 4, 5}; int ans = 0; for (int i = 0; i \u0026lt; 5; i++){ if(o.O(*\u0026amp;(i - 1)[i + 1] % 2 == 0)){ ans++; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 抽象实践 题目：求数组内偶数个数：\n思路：遍历数组，挨个判断元素是否为偶数\n正常代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; using namespace std; int mian(){ int a[] = {1, 2, 3, 4, 5}; int ans = 0; for(int i = 0;i \u0026lt; 5;i++){ if (a[i] % 2 == 0){ ans++; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 抽象代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #define false 1 #define true 0 #define _ int #define ___ 0 using namespace std; struct ZDJD{ bool O(bool IIllIIlllIIIIIIllIlIll){ return IIllIIlllIIIIIIllIlIll ? true : false; } }o; _ mian(){ _ IIIIIllIIlllllIIIl[] = {1, 2, 3, 4, 5}; _ IIIIIllIIIIIIllIlIlllIIlIlI = ___; for(_ __ = ___;__ \u0026lt; 5;__-=0xffffffff){ if (o.O(*\u0026amp;(__ - 1)[__ + 1] % 2 == 0)) { IIIIIllIIIIIIllIlIlllIIlIlI-=0xffffffff; } } cout \u0026lt;\u0026lt; IIIIIllIIIIIIllIlIlllIIlIlI \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; return 0; } ","date":"2023-08-16T11:17:42+08:00","permalink":"https://arturiamu.github.io/post/code-abstract/","title":"代码抽象艺术（bushi"},{"content":"Google 1、添加站点资源\n打开google search-console, 需要注册账号，按网域或网址前缀添加资源，按照要求下载验证文件放到网站根目录即可\n2、添加站点地图\n网站资源验证通过后，打开google 站点地图，将Hugo自动生成的sitemap.xml 地址添加进去即可（默认生成在根目录，例如我的博客域名为https://blog.mulinbiao.com/, 则默认生成的xml位置为 https://blog.mulinbiao.com/sitemap.xml\n添加成功后 Google 搜索引擎会定期访问网站根目录下的Sitemap.xml文件，并对其进行抓取。你也可以在每次博客更新后通过api主动通知Google搜索引擎（后面会讲）。\nBing 打开Bing Webmasters Tools,同样需要注册账号，注册成功后添加网站，添加sitemap.xml文件， 整体流程和 Google 差不多。\n添加成功后 Bing 搜索引擎会定期访问网站根目录下的Sitemap.xml文件，并对其进行抓取。你也可以在每次博客更新后通过api主动通知 Bing 搜索引擎（后面会讲） 或者打开bing url提交进行手动提交。\n百度 打开百度搜索资源平台 ，点击 资源提交，然后点\u0026quot;添加站点\u0026quot;。同样可以用文件验证的方式来进行网站验证。\n注意：百度不允许提交索引型sitemap，并且百度爬虫无法访问 GitHub ，如果使用 GitHub Page 部署网站，可以使用手动提交或者百度api提交（后面会讲）。\n脚本 在添加完网站和sitemap文件之后，可以在每次更新完博客内容后使用脚本进行批量提交，来加快网页被搜索引擎收录的速度，以下是各个搜索引擎提供的方式：\nGoogle：最方便，只需要手动或自动通知Google网站有内容更新即可 Bing：不是很方便，需要手动或自动将有更新的网页url发送到 bing Baidu：不是很方便，需要手动或自动将有更新的网页url发送到 bing 下面附上我的脚本\n（没做任何优化，实现的很潦草，仅供参考）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 package main import ( \u0026#34;bytes\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;gorm.io/driver/sqlite\u0026#34; \u0026#34;gorm.io/gorm\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;reflect\u0026#34; \u0026#34;regexp\u0026#34; \u0026#34;strings\u0026#34; ) const ( googleApi = \u0026#34;http://www.google.com/ping?sitemap={{your_sitemap_url}}\u0026#34; bingApi = \u0026#34;https://ssl.bing.com/webmaster/api.svc/json/SubmitUrlbatch?apikey={{your_api_key}}\u0026#34; baiduApi = \u0026#34;http://data.zz.baidu.com/urls?site={{your_site_url}}\u0026amp;token={{your token}}\u0026#34; //其他语言，看自己是否需要 zhFile = \u0026#34;xxx/sitemap.xml\u0026#34; jaFile = \u0026#34;xxx/sitemap.xml\u0026#34; enFile = \u0026#34;xxx/sitemap.xml\u0026#34; //简单保存提交记录，避免重复提交 databases = \u0026#34;url.db\u0026#34; siteGoogle = 0 siteBing = 1 siteBaidu = 2 ) var db *gorm.DB type Url struct { Url string Site int } func main() { var err error db, err = gorm.Open(sqlite.Open(databases), \u0026amp;gorm.Config{}) if err != nil { panic(err) } if err = db.AutoMigrate(\u0026amp;Url{}); err != nil { panic(err) } googleCommit() bingCommit() baiduCommit() } // 使用 ping 的方式请求谷歌抓取站点数据 func googleCommit() { response, err := http.Get(googleApi) if err != nil { fmt.Println(\u0026#34;google commit err: \u0026#34;, err) return } if response.StatusCode == http.StatusOK { fmt.Println(\u0026#34;google commit ok\u0026#34;) } else { body, _ := ioutil.ReadAll(response.Body) fmt.Println(\u0026#34;google commit err: \u0026#34;, string(body), response.StatusCode, response.Status) } } // 每天10000个url，没有月配额 func bingCommit() { urls, err := getUrlsFromXml(\u0026#34;\u0026#34;) if err != nil { fmt.Println(\u0026#34;bing commit err: \u0026#34;, err) return } urls, err = urlDeduplication(urls, siteBing) if err != nil { fmt.Println(\u0026#34;bing commit err: \u0026#34;, err) return } if urls == nil || len(urls) == 0 { fmt.Print(\u0026#34;bing commit nothing\u0026#34;) return } mp := map[string]interface{}{ \u0026#34;siteUrl\u0026#34;: \u0026#34;https://arturiamu.github.io\u0026#34;, \u0026#34;urlList\u0026#34;: urls, } js, err := json.Marshal(mp) if err != nil { fmt.Println(\u0026#34;bing commit err: \u0026#34;, err) return } request, err := http.NewRequest(\u0026#34;post\u0026#34;, bingApi, bytes.NewReader([]byte(js))) request.Header.Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) request.Header.Set(\u0026#34;charset\u0026#34;, \u0026#34;utf-8\u0026#34;) client := http.Client{} response, err := client.Do(request) if err != nil { fmt.Println(\u0026#34;bing commit err: \u0026#34;, err) return } bd, err := ioutil.ReadAll(response.Body) if err != nil { fmt.Println(\u0026#34;bing commit err: \u0026#34;, err) return } if response.StatusCode == http.StatusOK { fmt.Println(\u0026#34;bing commit ok\u0026#34;, string(bd)) for _, url := range urls { db.Create(\u0026amp;Url{Site: siteBing, Url: url}) } fmt.Println(\u0026#34;bing save url ok\u0026#34;) } else { fmt.Println(\u0026#34;bing commit err: \u0026#34;, string(bd), response.StatusCode, response.Status) return } } func baiduCommit() { urls, err := getUrlsFromXml(\u0026#34;blog.mulinbiao.com\u0026#34;) if err != nil { fmt.Println(\u0026#34;baidu commit err: \u0026#34;, err) return } urls, err = urlDeduplication(urls, siteBaidu) if err != nil { fmt.Println(\u0026#34;baidu commit err: \u0026#34;, err) return } if urls == nil || len(urls) == 0 { fmt.Print(\u0026#34;baidu commit nothing\u0026#34;) return } str := strings.Join(urls, \u0026#34;\\n\u0026#34;) request, err := http.NewRequest(\u0026#34;POST\u0026#34;, baiduApi, bytes.NewReader([]byte(str))) if err != nil { fmt.Println(\u0026#34;baidu commit err: \u0026#34;, err) return } //request.Header.Set(\u0026#34;User-Agent\u0026#34;, \u0026#34;curl/7.12.1\u0026#34;) //request.Header.Set(\u0026#34;Host\u0026#34;, \u0026#34;data.zz.baidu.com\u0026#34;) //request.Header.Set(\u0026#34;Content-Length\u0026#34;, \u0026#34;83\u0026#34;) request.Header.Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/plain\u0026#34;) client := http.Client{} response, err := client.Do(request) if err != nil { fmt.Println(\u0026#34;baidu commit err: \u0026#34;, err) return } bd, err := ioutil.ReadAll(response.Body) if err != nil { fmt.Println(\u0026#34;baidu commit err: \u0026#34;, err) return } if response.StatusCode == http.StatusOK { fmt.Println(\u0026#34;baidu commit ok\u0026#34;, string(bd)) for _, url := range urls { db.Create(\u0026amp;Url{Site: siteBaidu, Url: url}) } fmt.Println(\u0026#34;baidu save url ok\u0026#34;) } else { fmt.Println(\u0026#34;baidu commit err: \u0026#34;, string(bd), response.StatusCode, response.Status) return } } // 去重 func urlDeduplication(us []string, site int) (urls []string, err error) { var lst []Url err = db.Where(\u0026#34;site = ?\u0026#34;, site).Find(\u0026amp;lst).Error if err != nil { return } if lst != nil \u0026amp;\u0026amp; len(lst) \u0026gt; 0 { for _, u := range us { if indexUrlArr(lst, u) == -1 { urls = append(urls, u) } } } else { for _, u := range us { urls = append(urls, u) } } return urls, nil } func indexUrlArr(arr []Url, target string) int { for i, s := range arr { if s.Url == target { return i } } return -1 } // 由于使用blog.mulinbiao.com指向arturiamu.github.io // 百度只能提交blog.mulinbiao.com，需要做转换，看自己博客需求 func getUrlsFromXml(domain string) (urls []string, err error) { fzh, err := os.ReadFile(zhFile) if err != nil { fmt.Println(\u0026#34;open file err: \u0026#34;, err) return } fja, err := os.ReadFile(jaFile) if err != nil { fmt.Println(\u0026#34;open file err: \u0026#34;, err) return } fen, err := os.ReadFile(enFile) if err != nil { fmt.Println(\u0026#34;open file err: \u0026#34;, err) return } var arr []string var mp = make(map[string]struct{}) //使用正则表达式简单从xml中提取url，可以优化 r := regexp.MustCompile(`\\bhttps?://\\S+\\b`) arr = append(arr, r.FindAllString(string(fzh), -1)...) arr = append(arr, r.FindAllString(string(fja), -1)...) arr = append(arr, r.FindAllString(string(fen), -1)...) for _, a := range arr { aa := a if !strings.Contains(aa, \u0026#34;https://arturiamu.github.io\u0026#34;) { continue } if domain != \u0026#34;\u0026#34; { aa = strings.ReplaceAll(aa, \u0026#34;arturiamu.github.io\u0026#34;, domain) } aa = strings.ReplaceAll(aa, \u0026#34;\u0026lt;/loc\u0026#34;, \u0026#34;\u0026#34;) if !strings.HasSuffix(aa, \u0026#34;/\u0026#34;) { aa = aa + \u0026#34;/\u0026#34; } if _, ok := mp[aa]; ok { continue } mp[aa] = struct{}{} urls = append(urls, aa) } return urls, nil } ","date":"2023-08-09T16:17:15+08:00","permalink":"https://arturiamu.github.io/post/blog-seo/","title":"博客搜索引擎优化 SEO"},{"content":"为什么需要搭建集群 搭建主从同步集群可以实现MySQL数据库的高可用、可扩展和读写分离，提升系统的性能和稳定性。这在对数据库的可靠性、 并发读写能力和扩展性有较高要求的业务场景中尤为重要。\n主从同步原理 主数据库（Master）： 主数据库是数据变更的源头。它接收来自应用程序的写操作（INSERT、UPDATE、DELETE等）， 并记录这些操作在二进制日志（Binary Log）中， 这个过程叫做二进制日志事件 binary log events。\n从数据库（Slave）： 从数据库是主数据库的复制目标。它连接到主数据库，并通过读取主数据库的二进制日志来获取数据变更信息， 然后在从数据库上重现这些操作，从而保持与主数据库的数据一致性。改过程具体分为以下2个步骤：\nslave 将binary log events 拷贝到它的中继日志（relay_log）。 slave重做中继日志中的事件，将改变应用到自己的数据库中，mysql复制时异步的且串行化的 集群搭建流程 安装MySQL：在主库和从库上都安装MySQL数据库服务器。确保主库和从库的MySQL版本相同或兼容\nmaster 配置 1、打开主库的二进制日志功能。修改主机的配置文件（通常是my.cnf或my.ini），启用二进制日志，设置服务器ID。\n1 2 3 4 ...... log-bin = master-bin # 打开bin log日志文件，必须 server-id = 1 # 指定master服务id,必须 只要保证集群中唯一即可 ...... 2、启动主库MySQL服务，登陆root用户后创建主从复制用户slave并授权。\n1 2 3 4 5 6 # 登录 mysql -u root -p # 创建用户 slave，注意这里的ip是从库服务器的ip CREATE USER \u0026#39;slave\u0026#39;@\u0026#39;ip\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;123456\u0026#39;; # 给主从复制账号授权 grant replication slave on *.* to \u0026#39;slave\u0026#39;@\u0026#39;ip\u0026#39;; 3、重启主库的mysql服务，登录root查看配置是否生效\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 重启服务 service mysqld restart # 登录root mysql -u root -p # 查看配置 show master status; # 出现如下内容说明配置成功 +---------------+----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +---------------+----------+--------------+------------------+-------------------+ | binlog.000001 | 2463 | | | | +---------------+----------+--------------+------------------+-------------------+ 1 row in set (0.01 sec) slave配置 1、修改从库的配置文件，设置服务器ID，启用从库功能.\n1 2 3 ...... server-id = 2 #只要保证集群中唯一即可 ...... 2、重启服务并配置主从同步\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 重启服务 service mysqld restart # 登录 mysql -u root -p # 关闭从库 stop slave; # 设置同步，注意这里是主库ip，master_log_file和master_log_pos是配置master第3步中 show master status 命令查出的值 change master to master_host=\u0026#39;ip\u0026#39;,master_user=\u0026#39;slave\u0026#39;,master_password=\u0026#39;123456\u0026#39;,master_log_file=\u0026#39;mysql-bin.000001\u0026#39;,master_log_pos=2463; # 开启从库 start slave; # 检查服务器状态 show slave status \\G; # 看到Replica has read all relay log; waiting for more updates基本说明配置成功了，已经开始了主从复制。 ","date":"2023-07-21T16:48:07+08:00","permalink":"https://arturiamu.github.io/post/mysql-cluster-construction/","title":"MySQL主从同步集群搭建"},{"content":"本文从作者CSDN 解决 vue+axios+sprigboot 前后端分离项目 跨域请求资源和获取session不一致问题 同步\n直接上解决方法 跨域请求资源问题 后端添加过滤器，实现HandlerInterceptor接口，重写preHandle方法，添加如下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Component public class FilterConfig implements HandlerInterceptor { public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) throws Exception { } public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2) throws Exception { } @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object arg2) throws Exception { response.setHeader(\u0026#34;Access-Control-Allow-Origin\u0026#34;, request.getHeader(\u0026#34;Origin\u0026#34;)); // 允许请求跨域 response.setHeader(\u0026#34;Access-Control-Allow-Methods\u0026#34;, \u0026#34;GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS, PATCH\u0026#34;); response.setHeader(\u0026#34;Access-Control-Allow-Credentials\u0026#34;, \u0026#34;true\u0026#34;); // 允许请求携带session response.setHeader(\u0026#34;Access-Control-Allow-Headers\u0026#34;, \u0026#34;Authorization,Origin, X-Requested-With, Content-Type, Accept,Access-Token\u0026#34;); return true; } } 新建SpringMVCConfig类，继承WebMvcConfigurerAdapter类，自动注入FilterConfig 并设置过滤器拦截规则：\n1 2 3 4 5 6 7 8 9 @SpringBootConfiguration public class SpringMVCConfig extends WebMvcConfigurerAdapter { @Autowired private FilterConfig filterConfig; public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(filterConfig).addPathPatterns(\u0026#34;/**\u0026#34;); } } 以上配置能解决跨域请求，但是仍然存在每次请求session不一致问题，需要添加以下配置：\nsession不一致问题 vue2中，在main.js中引入axios并设置允许携带cookie：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import axios from \u0026#39;axios\u0026#39;; // 引入axios axios.defaults.withCredentials=true; // 设置请求默认携带cookie Vue.prototype.$axios = axios; // 可选，设置后可使用“this.$axios”发起请求 // ...正常配置 new Vue({ render: h =\u0026gt; h(App), store, router, // ... }).$mount(\u0026#39;#app\u0026#39;) // ...正常配置 在vue.config.js中添加代理设置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const {defineConfig} = require(\u0026#39;@vue/cli-service\u0026#39;) module.exports = defineConfig({ transpileDependencies: true, lintOnSave: false, devServer: { proxy: { // 添加代理设置 \u0026#39;/app\u0026#39;: { target: \u0026#39;http://xxx.xxx.xxx.xxx:xxxx/\u0026#39;, // 跨域目标地址 ws: true, changeOrigin: true, pathRewrite: { \u0026#39;^/app\u0026#39;: \u0026#34;\u0026#34; } } } } }) 发起跨域请求：\n1 this.$axios.post(\u0026#34;/app/xxx/xxx\u0026#34;) // 必须是\u0026#39;/app\u0026#39;开头。对应上面的\u0026#39;/app\u0026#39; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;2022年6月9日更新\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\n网站上线问题 测试发现使用以上设置上线后请求报404，将前端请求改为正常请求即可结局\n1 this.$axios.post(\u0026#34;/app/xxx/xxx\u0026#34;) // 改为\n1 this.$axios.post(\u0026#34;http://xxx.xxx.xxx.xxx:xxx/...\u0026#34;) 至此，vue+axios+springboot前后端分离项目中的跨域和session不一致问题完美解决！！！\n","date":"2023-06-23T16:37:15+08:00","permalink":"https://arturiamu.github.io/post/vue-axios-cors/","title":"vue axios 跨域问题"},{"content":"本文从作者CSDN springboot 普通类自动注入mapper 同步\n解决方法 普通类使用@Component注解修饰，添加本类型静态属性、所需mapper属性，添加init方法，用@PostConstruct注解修饰，方法内初始化以上2个属性：\n1 2 3 4 5 6 7 8 9 10 11 12 @Component public class VideoPool { private static VideoPool that; // 本类型静态属性 @Resource public VideoMapper videoMapper; // 所需要mapper @PostConstruct public void init() { that = this; that.videoMapper = this.videoMapper; } } 在类中需要使用mapper时，用that(本类型静态属性）.mapper：\n1 2 3 public static void run() { List\u0026lt;Item\u0026gt; itemList = that.itemMapper.getAll(); } ","date":"2023-06-23T16:28:51+08:00","permalink":"https://arturiamu.github.io/post/spring-boot-reject-mapper/","title":"springboot 普通类自动注入mapper"},{"content":"本文从作者CSDN专栏 蓝桥杯 Python B组 同步\n本专栏主要分享介绍蓝桥杯pythonB组备赛经验，希望可以帮到有需要的同学。\npython创建数组 直接定义法 1 matrix=[0,1,2,3] 间接定义法 1 2 a = 255 li = [0] * a 列表生成式 1 2 matrix=[0 for i in range(4)] matrix=[[0 for i in range(4)]for j in range(4)] ASCII码与字符相互转换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #以下代码用于实现ASCII码与字符相互转换： ## 用户输入字符 c = input(\u0026#34;请输入一个字符: \u0026#34;) ## 用户输入ASCII码，并将输入的数字转为整型 a = int(input(\u0026#34;请输入一个ASCII码: \u0026#34;)) print( c + \u0026#34; 的ASCII 码为\u0026#34;, ord(c)) print( a , \u0026#34; 对应的字符为\u0026#34;, chr(a)) #以上代码输出结果 #python3 test.py #请输入一个字符: a #请输入一个ASCII码: 101 #a 的ASCII 码为 97 #101 对应的字符为 e 列表转化为字符串 1 2 ls = [\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;] \u0026#34;\u0026#34;.join(ls) 修改字符串某一个字符 字符串是不可变的，不能直接修改\n转化法 1 2 3 4 5 s = \u0026#34;abc\u0026#34; temp = list(s) temp[2] = \u0026#34;d\u0026#34; s = \u0026#34;\u0026#34;.join(temp) print(s) replace函数 1 2 3 s = \u0026#34;abc\u0026#34; s = s.replace(\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;) print(s) 接收由空格分开的多个数据 1 ls = input().split() 同时改变列表中所有元素的类型 1 2 ls1 = input().split() ls2 = list(map(int,ls)) Python索引 python里面的索引的特征是包含起点，但是不包含结束的索引值，-1表示最后一个元素，但是-1是结尾的index，所以含义就是取原始数据的除最后一个元素之外的值\n逆序 1 li = li[::-1] 获取末尾元素 1 a = li[-1] 读取多行 使用python的标准输入函数，strip()是取出输入收尾的多余的空格、回车、缩进等等字符，在很多测试用例是必须的 map函数可以直接使用列表生成来替代 可以看到，此时可以一直读取输入，直到输入为空。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import sys try: while True: line1 = sys.stdin.readline().strip() if line1 == \u0026#39;\u0026#39;: break line2 = sys.stdin.readline().strip() a = int(line1) l = list(map(int, line2.split())) b = [int(n) for n in line2.split()] print(a) print(l) print(b) except: pass ","date":"2023-06-23T14:21:55+08:00","permalink":"https://arturiamu.github.io/post/lq-pyb-py-grammar/","title":"蓝桥杯 Python 语法"},{"content":"本文从作者CSDN专栏 蓝桥杯 Python B组 同步\n本专栏主要分享介绍蓝桥杯pythonB组备赛经验，希望可以帮到有需要的同学。\ngcd 1 2 def gcd(a,b): return a if b == 0 else gcd(b, a % b) lcm 1 2 def lcm(a,b): return a * b / gcd(a,b) leapyear 1 year % 4 == 0 and year % 100 != 0 or year % 400 == 0 floyed 1 2 3 4 5 6 7 8 9 10 11 12 n = 5 g = [[0,2,4,7,0], [2,0,1,0,2], [4,1,0,1,6], [7,0,1,0,0], [0,2,6,0,0]] for k in range(n): ## 无向图 节点个数 = 数组长度 for i in range(n): for j in range(n): if g[i][j] \u0026gt; g [i][k] + g[k][j]: g[i][j] = min(g[i][j], g[i][k] + g[k][j]); print(g[0][-1]) ## 4 简单dp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ## 最小路径和 def minPathSum(li,i,j): m = len(li) n = len(li[0]) return dp(li,m - 1, n - 1) memo = [[-1 for i in range(m)]for j in range(n)] def dp(li,i,j): if i == 0 and j == 0: return li[i][j] if(i \u0026lt; 0 or j \u0026lt; 0): return float(\u0026#39;inf\u0026#39;) if memo[i][j] != -1: return memo[i][j] memo[i][j] = math.min(dp(li,i - 1,j),dp(li,j - 1,i)) + li[i][j] return memo[i][j] ## 01背包 for i in range(1,m + 1): for j in range(1,n + 1): dp[i][j] = dp[i - 1][j] if j \u0026gt;= vs[i]: dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - vs[i]] + ws[i]) 回溯求全排列 1 2 3 4 5 6 7 8 9 10 11 12 13 li = [1,2,3] ans = [] def backtrack(st,ed): if st == ed: ans.append(li[:]) return for i in range(st,ed): li[i],li[st] = li[st],li[i] backtrack(st + 1,ed) li[i],li[st] = li[st],li[i] backtrack(0,len(li)) print(ans) 素数一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import math def check(n): if(n \u0026lt;= 3): return n \u0026gt; 1 if(n % 6 != 1 and n % 6 != 5): return False for i in range(5,int(math.sqrt(n)) + 1,6): if n % i == 0 or n % (i + 2) == 0: return False return True for i in range(100): if check(i): print(i) 素数二 1 2 3 4 5 6 7 8 9 10 n = 100 ns = [False] * (n + 1) for i in range(2, n + 1): if ns[i]: continue print(i) for j in range(i,n//i + 1): ns[i * j] = True 二叉树遍历 1 2 3 4 5 6 7 8 def traverse(root): if not root: return ## 前序遍历 traverse(root.left) ## 中序遍历 traverse(root.right) ## 后序遍历 并查集 1 2 3 4 5 6 7 8 9 parent=[i for i in range(n)] def union(p,q): parent[find[p]] = find[q] def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x]; def isConn(p,q): return find(p) == find(q) 位运算技巧 1 2 3 4 5 6 7 8 (\u0026#39;a\u0026#39; | \u0026#39; \u0026#39;) = \u0026#39;a\u0026#39; (\u0026#39;A\u0026#39; | \u0026#39; \u0026#39;) = \u0026#39;a\u0026#39; (\u0026#39;b\u0026#39; \u0026amp; \u0026#39;_\u0026#39;) = \u0026#39;B\u0026#39; (\u0026#39;B\u0026#39; \u0026amp; \u0026#39;_\u0026#39;) = \u0026#39;B\u0026#39; (\u0026#39;d\u0026#39; ^ \u0026#39; \u0026#39;) = \u0026#39;D\u0026#39; (\u0026#39;D\u0026#39; ^ \u0026#39; \u0026#39;) = \u0026#39;d\u0026#39; 数论 等比数列求和 $a1(1-q^n)/(1-q)$\n等差数列求和 $n(a1+an)/2$\n","date":"2023-06-23T14:08:55+08:00","permalink":"https://arturiamu.github.io/post/lq-py-code-template/","title":"蓝桥杯 Python B组-代码模板"},{"content":"本文从作者CSDN专栏 蓝桥杯 Python B组 同步\n本专栏主要分享介绍蓝桥杯pythonB组备赛经验，希望可以帮到有需要的同学。\n输入输出 输入 input()接收str,需要进行类型转换\n单个数字输入：n = int(input())\n多个数字输入：a, b = map(int, input().spilt(\u0026rsquo;\u0026rsquo;))\n多个数字输入接收为列表：nums = list(map(int, input().spilt(\u0026rsquo;\u0026rsquo;)))\n输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ## 隔空输出 a = [1,2,3,4] print(\u0026#39; \u0026#39;.join(map(str,a))) #1 2 3 4 ## 四舍五入 a = 3.1415926 print(int(a + 0.5)) ## 保留两位 a = 3.1415926 print(\u0026#34;%.2f\u0026#34;%a) 常用函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 abs() ## 取绝对值 divmod() ## 同时取商和余 divmod(7,2)-\u0026gt;(3, 1) sum() ## 求和 min() ## 求最小值 max() ## 求最大值 round() ## 四舍五入 ‘%.3f’%x \u0026#34;{:.3f}\u0026#34;.format(x) round(x,3) ## 保留3位小数 math.ceil() ## 向上取整 math.floor ## 向下取整 pow() ## 求幂 等价于** pow(25,1/2)开方 hex() ## 十进制转十六进制 oct() ## 十进制转八进制 bin() ## 十进制转二进制 bool() ## 将指定参数转为bool类型 float() ## 转换为浮点数 int() ## 转换为整数,其他进制转为十进制 int(\u0026#39;11\u0026#39;,2)-\u0026gt;3 ord() ## 获取单个字符的ASCII数值 chr() ## 将整数转换为其值对应的ASCII/Unicode字符 range() ## 创建一个可迭代对象 all() ## 指定序列中所有元素都为True返回True否则返回False any() ## 指定序列中只要有一个元素为True返回True否则返回False sorted() ## 对可迭代对象进行排序 sorted(iters, key = lambda x: x + 1) list() ## 将可迭代对象转换为列表 set() ## 创建一个无序不重复的元素集合 map() ## 通过自定义函数实现对序列的元素映射操作并返回操作后的结果 open() ## 打开文件并返回文件对象 fp.readlines() ## 读取文件所有行（包括换行符，可以使用line.strip(\u0026#39;\\n\u0026#39;)删除） format() ## 格式化数据 \u0026#34;{} {}\u0026#34;.format(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;)、\u0026#34;{:.2f}\u0026#34;.format(3.1415926) input() ## 接收用户输入并返回所输入的string类型数据 len() ## 返回一个对象的元素或项目个数 字符串操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from collections import Counter st = \u0026#39;hello world\u0026#39; Counter(st) ### Counter({\u0026#39;l\u0026#39;: 3, \u0026#39;o\u0026#39;: 2, \u0026#39;h\u0026#39;: 1, \u0026#39;e\u0026#39;: 1, \u0026#39; \u0026#39;: 1, \u0026#39;w\u0026#39;: 1, \u0026#39;r\u0026#39;: 1, \u0026#39;d\u0026#39;: 1}) string.split(str=\u0026#34;\u0026#34;, num=string.count(str)) ## 通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则分隔 num+1 个子字符串，不填则默认为空格。 string.decode(encoding=\u0026#39;UTF-8\u0026#39;,errors=\u0026#39;strict\u0026#39;) ## 指定的编码格式解码字符串 string.encode(encoding=\u0026#39;UTF-8\u0026#39;,errors=\u0026#39;strict\u0026#39;) ## 指定的编码格式编码字符串 string.encode(encoding=\u0026#39;UTF-8\u0026#39;,errors=\u0026#39;strict\u0026#39;) ## 指定的编码格式编码字符串 string.count(str, beg=0, end=len(string)) ## 统计str出现次数，可指定开始/结束位置 string.endswith(str, beg=0, end=len(string)) ## 判断是否以str结束，可指定开始/结束位置 string.find(str, beg=0, end=len(string)) ## 查找str,未找到返回-1 string.index(str, beg=0, end=len(string)) ## 查找str,未找到抛出异常 string.join(seq) ## 将seq中的各项以string为连接符拼接 string.strip([obj]) ## 去除首位指定字符 等价于string.lstrip() -\u0026gt; string.rstrip() string.upper() ## 转为大写 string.lower() ## 转为小写 string.swapcase() ## 转换大小写 时间日期操作 1 2 3 4 5 6 7 8 9 datetime.datetime.now() ## 2019-08-14 12:52:55.817273 datetime. datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]) datetime.date（year，month，day) datetime.time([hour[, minute[, second[, microsecond[, tzinfo]]]]]) datetime.strftime(\u0026#34;%H\u0026#34;) 列表操作 1 2 3 4 5 6 7 8 9 10 11 list.append() ## 增加 list.insert() ## 插入 list.pop() ## 删除 list[m:n] ## 切片，从m开始到n-1 list1=list[::-1] ## 表示list1是list的逆序 \u0026#39;\u0026#39;.join(list) ## 把list中的元素合成一个字符串 正则表达式 1 2 3 4 5 import re s = \u0026#39;Regular 123 Expression 456\u0026#39; re.findall(r\u0026#39;\\d+\u0026#39;,s) 匹配规则 ^：匹配字符串开头\n\u0026ldquo;*\u0026rdquo; 匹配前面的子表达式零次或多次\n\u0026ldquo;+\u0026rdquo; 匹配前面的子表达式一次或多次\n\u0026ldquo;?\u0026rdquo; 匹配前面的子表达式零次或一次\n\u0026ldquo;[abc]\u0026rdquo; ：方括号表示字符集合，例子表示一个字符串有一个 \u0026ldquo;a\u0026rdquo; 或 \u0026ldquo;b\u0026rdquo; 或 \u0026ldquo;c\u0026rdquo; 等价于 [z|b|c]\n\u0026ldquo;[a-z]\u0026quot;： 表示一个字符串中存在一个 a 和 z 之间的所有字母\n\u0026ldquo;[^a-z]\u0026rdquo; ：表示一个字符串中不应该出现 a 到 z 之间的任意一个字母\n\u0026ldquo;[0-9]\u0026quot;： 表示一个字符串中存在一个 0 和 9 之间的所有数字\n\u0026ldquo;\\d \u0026quot; 匹配一个数字字符，等价[0-9]\n\u0026ldquo;\\D \u0026quot; 匹配一个非数字字符，等价[^0-9]\n\u0026ldquo;\\w\u0026rdquo; 匹配包括下划线的任何单词字符。等价于\u0026rdquo;[A-Za-z0-9_]\u0026rdquo;\n\u0026ldquo;\\W\u0026rdquo; 匹配任何非单词字符。等价于\u0026rdquo;[^A-Za-z0-9_]\u0026rdquo;\n注意：正则语法中^匹配行开头、\\A匹配字符串开头，单行模式下它两效果一致，多行模式下\\A不能识别\n","date":"2023-06-23T14:05:35+08:00","permalink":"https://arturiamu.github.io/post/lq-pyb-py/","title":"蓝桥杯 Python B组-Python基础"},{"content":"本文从作者CSDN专栏 蓝桥杯 Python B组 同步\n本专栏主要分享介绍蓝桥杯pythonB组备赛经验，希望可以帮到有需要的同学。\n我参加的是2022年的pythonB组，本来是只打算混混省赛的，可能是今年省赛比较简单，加上运气比较好，混到了国二，排名在1/3左右，说实话挺意外的。\n比赛基本上是零基础开始准备的，省赛之后因为项目比较忙，自己也是一心摆烂，直接没有准备国赛，到国赛时候写个dfs都要推半天了。其实还是有点遗憾的，当初要是好好准备一个月说不定国一就有了。\n写这个文集主要是因为当初本人备赛时候基本没什么Python组的经验贴，有一些题解还需要收费，确实很不容易。（因为时间关系，这里的题解就随缘更了）\n所以想把自己的经验给大家分享，希望小白可以少走一些弯路！！！\n难度 蓝桥杯在程序设计竞赛中来说算是难度比较低的了（当然近年来难度也在逐渐提高），很多人称蓝桥杯为暴力杯，尤其是省赛，只要会基本的dfs就能混点分，当然这种情况也在逐年减少，但是客观来说蓝桥杯确实不难，只要备赛方法得当，拿个奖完全没问题，大家没必要太担心。\n赛制 蓝桥杯为个人赛，一共有十道题目，往年是5填空+5代码，今年改成了2填空+8代码，之后不知道还会不会调整。\n填空题都是给出题面，并且保证只有一个正确答案，选手只需要计算出答案提交结果就行，不限制计算方法，你可以使用电脑上的任何软件，比如计算器、Excel\u0026hellip;\n代码题需要提交代码，跑通给定的测试用例，也就是OJ的形式。题目完全为客观题型，选手所提交作答的运行结果为主要评分依据。\n比赛不能携带资料，但是可以查看python自带的文档，会提供草稿纸\n注意事项 只能使用Python标准库\n只能使用Python自带的IDE\n","date":"2023-06-23T13:17:35+08:00","permalink":"https://arturiamu.github.io/post/lq-pyb-desc/","title":"蓝桥杯 Python B组-说明"},{"content":"bug日志 2023-06-20-16:30:34 bug描述 博客评论功能不可用，具体表现为：\n博客末评论处尾显示\u0026quot;未找到相关的 Issues 进行评论，请联系xxx初始化创建\u0026quot;字样 点击\u0026quot;使用GitHub登录\u0026quot;后跳转回该博客，无其他反应 bug溯源 Google查到可能是博客uri过长，经排查后发现并不是该问题导致\n观察后发现页面跳转时候地址栏网址后带了错误参数\u0026quot;error=redirect_urixxx\u0026quot;等字样，推测是GitHub回调错误。\n排查后发现是由于之前绑定了 blog.mulinbiao.com 域名，未更新GitHub OAuth 配置的 callback 导致\nbug修复 打开GitHub settings -\u0026gt; developer settings -\u0026gt; OAuth Apps，将APP配置的 Homepage URL 和 Authorization callback URL 改为 https://blog.mulinbiao.com/ 即可\n","date":"2023-06-18T13:14:35+08:00","permalink":"https://arturiamu.github.io/post/blog-bug-log/","title":"博客bug日志"},{"content":"前序 很早之前就很想要开个自己的博客， 但是一直都比较忙（lǎn），趁着临近毕业的空隙，才终于决定抽出时间开始实现。开这个博客的主要目的有如下两个：\n记录生活和思考\n写博客可以将自己的经验、感悟、思考和见解以文字的形式记录下来，不仅可以帮助自己更好地理清思路和总结经验，也能够与他人分享自己的心路历程。\n交流和学习\n博客也是一个交流和学习的平台，可以与其他博主、读者和同行交流和分享自己的经验和见解，从而获得更多的启发和学习机会。\n关于本博客 本博客使用 Hugo+Github Pages搭建，详细过程请自行参考 如何用 GitHub Pages + Hugo 搭建个人博客 以及 个人博客记 —— Github pages 绑定个人域名 。 另外，出于学习外语的目的，我会尽量同时发布中英日版本博客，若发现语言或内容上的错误，欢迎批评指正。\n本博客使用二级域名 blog.mulinbiao.com 解析到 arturiamu.github.io，由于 blog.mulinbiao.com 域名涉及到续费、备案等问题，连通性无法得到保障，建议使用 arturiamu.github.io 进行访问。\n许可协议 除特别声明外，本站点所有文章均使用 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 知识共享许可协议\n您可以自由地： 共享 — 在任何媒介以任何形式复制、发行本作品\n演绎 — 修改、转换或以本作品为基础进行创作\n只要你遵守许可协议条款，许可人就无法收回你的这些权利。\n惟须遵守下列条件： 署名 — 您必须给出适当地署名，提供指向本许可协议的链接，同时标明是否（对原始作品）作了修改。您可以用任何合理的方式来署名，但是不得以任何方式暗示许可人为您或您的使用背书。\n非商业性使用 — 您不得将本作品用于商业目的。\n相同方式共享 — 如果您再混合、转换或者基于本作品进行创作，您必须基于与原先许可协议相同的许可协议 分发您贡献的作品。\n没有附加限制 — 您不得适用法律术语或者 技术措施 从而限制其他人做许可协议允许的事情。\n声明 您不必因为公共领域的作品要素而遵守许可协议，或者您的使用被可适用的 例外或限制所允许。\n不提供担保。许可协议可能不会给与您意图使用的所必须的所有许可。例如，其他权利比如形象权、隐私权或人格权可能限制您如何使用作品。\n","date":"2023-06-18T12:25:48+08:00","permalink":"https://arturiamu.github.io/post/blog-description/","title":"博客说明"}]